# 浏览器缓存机制

## 概述

缓存是性能优化中简单高效的一种优化方式.一个优秀的缓存策略可以缩短网页请求的资源距离,减少延迟,并且由于缓存文件可以重复利用,还可以减少带宽,降低网络负荷.

对于一个数据请求来说,可以分为`发起网络请求`-->`后端处理`-->`浏览器响应`三个步骤.浏览器缓存可以帮助我们在第一和第三步中优化性能.比如说直接使用缓存不发起请求,或者发起了请求但是后端存储的数据和前端一致,那么就没有必要再将数据返回回来,这样就减少了响应数据.

本文通过`缓存位置`,`缓存策略`,`实际应用场景`这几个方面来讨论浏览器机制
![eee3901268cd35861dd2434112f5bd38.png](evernotecid://2690CA97-501C-486E-863F-92721248DCFB/appyinxiangcom/14568029/ENResource/p335)

## 缓存位置

从缓存位置上来说分为四种,并且各自有优先级,当依次查找缓存且没有命中的时候,才会去请求网络.

* Service Worker
* Memory Cache
* Disk Cache
* Push Cache

### Service Worker

`Service Worker`是运行在浏览器背后的独立线程,一般可以用来实现缓存功能.使用`Service Worker`的话,**传输协议必须是`HTTPS`**.因为`Service Worker`中涉及到请求拦截,所以必须使用`HTTPS`协议来保障安全.**`Service Worker`的缓存与浏览器其它内建的缓存机制不同,它可以让我们自由控制缓存哪些文件,如何匹配缓存,如何读取缓存,并且缓存是持续性的.**

`Service Worker`实现缓存功能一般分三个步骤:**首先,**需要先注册`Service Worker`,**然后**监听到`install`事件以后就可以缓存需要的文件,**最后**在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存,存在缓存的话就可以直接读取文件,否则就去请求数据.

当`Service Worker`没有命中缓存的时候,我们需要调用`fetch`函数获取数据.也就是说,如果我们没有在`Service Worker`命中缓存的话,会根据缓存查找优先级去查找数据.但是不管我们是从`Memory Cache`中还是网络请求中获取的数据,浏览器都会显示我们是从`Service Worker`中获取的内容.

### Memory Cache

`Memory Cache`也就是内存中的缓存,主要包含的是当前页面中已经抓取到的资源,例如页面上已经下载的样式,脚本,图片等.读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效,但是缓存的持续性很短,会随着进程的释放而释放.**一旦我们关闭tab页面,内存中的缓存也就被释放了**, **另外,计算机内存容量有限,我们不能把所有数据都放在内存中缓存**

当我们访问过页面以后,再次刷新页面,可以发现很多数据都来自于内存缓存.
![86b35a3a899d345976bae7c4e8de9664.png](evernotecid://2690CA97-501C-486E-863F-92721248DCFB/appyinxiangcom/14568029/ENResource/p336)

内存缓存中有一块重要的缓存资源是`preloader`相关指令(例如`<link rel="prefetch">`)下载的资源.众所周知`preloader`的相关指令已经是页面优化的常见手段之一,它可以一边解析`js/css`文件,一边网络请求下载一个资源.

需要注意的是,**内存缓存在缓存资源时并不关心返回资源的HTTP缓存头`Cache-Control`是什么值,同事资源的匹配也并非仅仅是对`URL`做匹配,还可能会对`Content-Type`,`CORS`等其他特征做校验.

### Disk Cache
